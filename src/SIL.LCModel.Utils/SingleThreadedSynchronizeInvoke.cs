// Copyright (c) 2015 SIL International
// This software is licensed under the LGPL, version 2.1 or later
// (http://www.gnu.org/licenses/lgpl-2.1.html)

using System;
using System.ComponentModel;
using System.Threading;

namespace SIL.LCModel.Utils
{
	/// <summary>
	/// A simple, single-threaded implementation of ISynchronizeInvoke
	/// </summary>
	public class SingleThreadedSynchronizeInvoke : ISynchronizeInvoke
	{
		/// <summary>
		/// Asynchronously executes the delegate on the thread that created this object.
		/// </summary>
		/// <param name="method">A <see cref="T:System.Delegate" /> to a method that takes parameters of the same number and type that are contained in <paramref name="args" />.</param>
		/// <param name="args">An array of type <see cref="T:System.Object" /> to pass as arguments to the given method. This can be null if no arguments are needed.</param>
		/// <returns>
		/// An <see cref="T:System.IAsyncResult" /> interface that represents the asynchronous operation started by calling this method.
		/// </returns>
		public IAsyncResult BeginInvoke(Delegate method, object[] args)
		{
			return new AsyncResult(method.DynamicInvoke(args));
		}

		/// <summary>
		/// Waits until the process started by calling <see cref="M:System.ComponentModel.ISynchronizeInvoke.BeginInvoke(System.Delegate,System.Object[])" /> completes, and then returns the value generated by the process.
		/// </summary>
		/// <param name="result">An <see cref="T:System.IAsyncResult" /> interface that represents the asynchronous operation started by calling <see cref="M:System.ComponentModel.ISynchronizeInvoke.BeginInvoke(System.Delegate,System.Object[])" />.</param>
		/// <returns>
		/// An <see cref="T:System.Object" /> that represents the return value generated by the asynchronous operation.
		/// </returns>
		public object EndInvoke(IAsyncResult result)
		{
			return ((AsyncResult) result).Result;
		}

		/// <summary>
		/// Synchronously executes the delegate on the thread that created this object and marshals the call to the creating thread.
		/// </summary>
		/// <param name="method">A <see cref="T:System.Delegate" /> that contains a method to call, in the context of the thread for the control.</param>
		/// <param name="args">An array of type <see cref="T:System.Object" /> that represents the arguments to pass to the given method. This can be null if no arguments are needed.</param>
		/// <returns>
		/// An <see cref="T:System.Object" /> that represents the return value from the delegate being invoked, or null if the delegate has no return value.
		/// </returns>
		public object Invoke(Delegate method, object[] args)
		{
			return method.DynamicInvoke(args);
		}

		/// <summary>
		/// Gets a value indicating whether the caller must call <see cref="M:System.ComponentModel.ISynchronizeInvoke.Invoke(System.Delegate,System.Object[])" /> when calling an object that implements this interface.
		/// </summary>
		/// <returns>true if the caller must call <see cref="M:System.ComponentModel.ISynchronizeInvoke.Invoke(System.Delegate,System.Object[])" />; otherwise, false.</returns>
		public bool InvokeRequired
		{
			get { return false; }
		}

		private class AsyncResult : IAsyncResult
		{
			private readonly object m_result;

			public AsyncResult(object result)
			{
				m_result = result;
			}

			public object Result
			{
				get { return m_result; }
			}

			public bool IsCompleted
			{
				get { return true; }
			}

			public WaitHandle AsyncWaitHandle
			{
				get { throw new NotSupportedException(); }
			}

			public object? AsyncState
			{
				get { return null; }
			}

			public bool CompletedSynchronously
			{
				get { return true; }
			}
		}
	}
}
